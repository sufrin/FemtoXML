package femtoXML.app;
import java.util.concurrent.SynchronousQueue;

/** A form of iterator whose elements are generated by an independent thread. This is useful
 *  in situation where the ''natural'' way of programming the generation of the elements is
 *  recursive, but where it is inconvenient or error-prone to program the recursion 
 *  housekeeping explicitly.   
 *  
 *  The following example generates all the elements in a tree that are more than K levels below the root.
 * <pre>
 * <code>
 *    Cursor<Node> gen = new Generator<Node>();
      {   void generate(Node n, int l) { if (!closed && l>K) { put(n); generate(n.left, l+1); generate(n.right, l+1); } }
          
          public void gen() { generate(root, 0); }
      };
 * </code>
 * </pre>
 * 
 * The implementation is unbuffered: each <code>put</code> in the generator thread is synchronized with the corresponding <code>next()</code>
 * from the consuming thread. The consumer can signal the generator that it has no further interest by calling <code>close()</code>.
 * */

public abstract class Generator<T> extends Cursor<T> implements Runnable {
	
    SynchronousQueue<T> chan = new SynchronousQueue<T>(); // channel from generator to iterator
    boolean closed = false, finishedPutting = false;
    Thread  thread = null;
    T       buf    = null;
    
    /** Construct an instance of the generator and start generating immediately */
    public Generator() {
      thread = new Thread(this);
      System.err.println("Starting "+this);
      thread.start();
    }
    
    public void close() { closed = true; }
    
    /** Generate an element */
    protected void put(T t) {
			if (!closed)
				try {
			      chan.put(t);
		        } catch (InterruptedException e) {
		        } 
	}
	
    /** This must be defined. It should generate and deliver (all the) elements using put.
     * @TODO use a specific private exception to signify closed instead of IllegalStateException  
     */
    abstract public void gen();
    
    public void run() { try { gen(); } finally { put(null); finishedPutting=true; closed=true; } }
    
    public Cursor<T> copy()
    { final Generator<T> parent = this;
      return new Generator<T>() { public void gen() { parent.gen(); } };
    }
    
    @SuppressWarnings("finally")
	public boolean hasNext() { 
    	   if (finishedPutting) return false;
    	   try 
    	   { if (buf==null) buf = chan.take(); }
           finally
           { return buf!=null; }
    }
    
    /** Returns the next generated element
     */
    public T next() {
    	T res = buf;
    	buf = null;
    	return res;
    }
    
    
    public static void main(String[] arg)
    {
      Cursor<Integer> g = new Generator<Integer>()
      {
    	  public void gen()
    	  {   System.err.println(this);
    		  for (int i=0; !closed && i<20; i++) put(i);
    	  }
      };
      while (g.hasNext()) { System.err.println(g.next()); System.err.flush(); } 
      Cursor<Integer> g1 = g.copy();
      while (g1.hasNext()) { System.err.println(g1.next()); System.err.flush(); } 
    }

}
